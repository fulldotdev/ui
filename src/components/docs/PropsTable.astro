---
import Table from 'fulldev-ui/components/Table.astro'
import { readFileSync } from 'node:fs'
import { pascal } from 'radash'

const slug = Astro.url.pathname.replace(/\/$/, '').split('/').pop() || ''
const componentName = pascal(slug)

const allComponents = import.meta.glob('src/**/*.astro', { eager: true })
const foundComponent = Object.entries(allComponents).find(
  ([key]) => key.split('/').pop() === `${componentName}.astro`
)?.[1] as any
const foundContent =
  foundComponent && readFileSync(foundComponent.file, 'utf-8')

const componentFileContent = foundContent || ''

interface Prop {
  name: string
  type: string
}

// Regular expression to match the Props interface or type
const staticProps = /(?:interface|type)\s+Props[\s\S]*?{([\s\S]*?)}/

// Function to extract props from the component file
const extractProps = (content: string): Prop[] => {
  const props: Prop[] = []

  // Extract static props from Props interface or type
  const staticPropsMatch = content.match(staticProps)
  if (staticPropsMatch && staticPropsMatch[1]) {
    const propsContent = staticPropsMatch[1]
    const propLines = propsContent.split('\n')

    let currentProp: Prop | null = null

    propLines.forEach((line) => {
      const trimmedLine = line.trim()
      if (trimmedLine === '') return

      // Match prop name and type
      const match = trimmedLine.match(/^(\w+)(\??):(.*)/)
      if (match && match[1] && match[3]) {
        if (currentProp) props.push(currentProp)
        currentProp = {
          name: match[1],
          type: match[3].trim(),
        }
      } else if (currentProp) {
        // Continue adding to type if it spans multiple lines
        currentProp.type += ' ' + trimmedLine
      }
    })

    if (currentProp) props.push(currentProp)
  }

  // Extract props from type intersections
  const intersectionProps = content.match(
    /Props(?:<[^>]+>)?\s*=\s*([\s\S]*?)(?:$|\n\n)/
  )
  if (intersectionProps && intersectionProps[1]) {
    const intersectionContent = intersectionProps[1]
    let currentProp: Prop | null = null
    const lines = intersectionContent.split('\n')

    lines.forEach((line) => {
      const trimmedLine = line.trim()
      if (trimmedLine === '') return

      // Match prop name and type
      const match = trimmedLine.match(/(\w+)(\??):(.*)/)
      if (match && match[1] && match[3]) {
        if (currentProp) props.push(currentProp)
        currentProp = {
          name: match[1],
          type: match[3].trim(),
        }
      } else if (currentProp) {
        // Continue adding to type if it spans multiple lines
        currentProp.type += ' ' + trimmedLine
      }
    })

    if (currentProp) props.push(currentProp)
  }

  // Clean up the type of the last prop
  if (props.length > 0) {
    const lastProp = props[props.length - 1]
    if (lastProp) {
      lastProp.type = lastProp.type.replace(/\s*}\s*$/, '')
    }
  }

  // Filter out 'as' prop and props starting with underscore
  return props.filter(
    (prop) => prop.name !== 'as' && !prop.name.startsWith('_')
  )
}

// Function to extract default prop values from Astro.props
const extractDefaultProps = (content: string): Record<string, string> => {
  const defaultPropsMatch = content.match(
    /const\s*{[\s\S]*?}\s*=\s*Astro\.props/
  )
  return defaultPropsMatch
    ? [
        ...defaultPropsMatch[0].matchAll(
          /(\w+)\s*=\s*('[^']*'|"[^"]*"|[^,\n]+)/g
        ),
      ].reduce(
        (acc, match) => {
          const [, name, value] = match
          if (name && name !== 'as' && value !== undefined) {
            acc[name] =
              value.startsWith("'") || value.startsWith('"')
                ? value.slice(1, -1)
                : value
          }
          return acc
        },
        {} as Record<string, string>
      )
    : {}
}

// Function to extract the default 'as' prop value
const extractAsDefault = (content: string): string => {
  const asDefaultMatch = content.match(/as\s*=\s*([^,\n]+)/)
  if (asDefaultMatch && asDefaultMatch[1]) {
    let asDefault = asDefaultMatch[1]
      ?.split(' : ')[0]
      ?.trim()
      ?.replace(/['"]/g, '')
      ?.replace(/href \? a : /, '')
      ?.replace(/href \? 'a' : /, '')

    asDefault = asDefault?.replace(/^{/, '').replace(/}$/, '')

    return asDefault?.includes('?') ? `{${asDefault}}` : asDefault || 'div'
  }
  return 'div'
}

const parsedProps = extractProps(componentFileContent)
const parsedAstroProps = extractDefaultProps(componentFileContent)
const asDefault = extractAsDefault(componentFileContent)

// Function to get the default value for a prop
const getDefaultValue = (name: string): string => {
  if (name in parsedAstroProps) {
    return parsedAstroProps[name] || '-'
  }

  return '-'
}

// Prepare the table body data
const tableBody = [
  ...parsedProps.map((item) => [
    item.name,
    item.type.replace(/\s*\|?\s*undefined/, '').trim(),
    getDefaultValue(item.name),
  ]),
  ['as', 'HTMLTag', asDefault],
  ['HTML Attributes', `Polymorphic<${asDefault}>`, '-'],
]
---

<Table
  size="md"
  class:list={['props-table']}
  header={['Prop', 'Type', 'Default']}
  body={tableBody}
/>

<style is:global lang="scss">
  .props-table {
    overflow: auto;
  }
</style>
