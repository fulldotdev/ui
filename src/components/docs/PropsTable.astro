---
// This component is experimental
// @ts-nocheck
import Table from 'fulldev-ui/components/Table.astro'
import { readFileSync } from 'node:fs'

const slug = Astro.url.pathname.replace(/\/$/, '').split('/').pop() || ''
const component = slug.charAt(0).toUpperCase() + slug.slice(1)

const allComponents = await Astro.glob('../../components/**/*.astro')
const found = allComponents.find(
  (c) => c.file.split('/').pop()?.replace('.astro', '') === component
)

if (!found) return

const componentFileContent = readFileSync(found.file, 'utf-8')

// Function to extract props from the component file
const extractProps = (content: string) => {
  const props = []

  // Extract props from interface or type definition
  // Regex: Matches 'interface Props' or 'type Props', captures everything between curly braces
  const propsMatch = content.match(
    /(?:interface|type)\s+Props[\s\S]*?{([\s\S]*?)}/
  )
  if (propsMatch) {
    const propsContent = propsMatch[1]
    const propLines = propsContent.split('\n')

    let currentProp = null

    propLines.forEach((line) => {
      const trimmedLine = line.trim()
      if (trimmedLine === '') return

      // Regex: Matches prop name, optional question mark, and type
      const match = trimmedLine.match(/^(\w+)(\??):(.*)/)
      if (match) {
        if (currentProp) props.push(currentProp)
        currentProp = {
          name: match[1],
          type: match[3].trim(),
        }
      } else if (currentProp) {
        currentProp.type += ' ' + trimmedLine
      }
    })

    if (currentProp) props.push(currentProp)
  }

  // Extract props from type intersections
  // Regex: Matches 'Props =' or 'Props<T> =', captures everything until end of file or double newline
  const intersectionProps = content.match(
    /Props(?:<[^>]+>)?\s*=\s*([\s\S]*?)(?:$|\n\n)/
  )
  if (intersectionProps) {
    const intersectionContent = intersectionProps[1]
    let currentProp = null
    const lines = intersectionContent.split('\n')

    lines.forEach((line) => {
      const trimmedLine = line.trim()
      if (trimmedLine === '') return

      // Regex: Matches prop name, optional question mark, and type
      const match = trimmedLine.match(/(\w+)(\??):(.*)/)
      if (match) {
        if (currentProp) props.push(currentProp)
        currentProp = {
          name: match[1],
          type: match[3].trim(),
        }
      } else if (currentProp) {
        currentProp.type += ' ' + trimmedLine
      }
    })

    if (currentProp) props.push(currentProp)
  }

  // Clean up the type of the last prop
  if (props.length > 0) {
    const lastProp = props[props.length - 1]
    // Regex: Removes trailing closing brace and whitespace
    lastProp.type = lastProp.type.replace(/\s*}\s*$/, '')
  }

  return props.filter(
    (prop) => prop.name !== 'as' && !prop.name.startsWith('_')
  )
}

// Function to extract default prop values
const extractDefaultProps = (content: string) => {
  // Regex: Matches Astro.props destructuring
  const defaultPropsMatch = content.match(
    /const\s*{[\s\S]*?}\s*=\s*Astro\.props/
  )
  return defaultPropsMatch
    ? [
        ...defaultPropsMatch[0].matchAll(
          // Regex: Matches prop name and its default value
          /(\w+)\s*=\s*('[^']*'|"[^"]*"|[^,\n]+)/g
        ),
      ].reduce(
        (acc, [, name, value]) => {
          if (name !== 'as') {
            acc[name] =
              value.startsWith("'") || value.startsWith('"')
                ? value.slice(1, -1)
                : value
          }
          return acc
        },
        {} as Record<string, string>
      )
    : {}
}

// Function to extract the default 'as' prop value
const extractAsDefault = (content: string) => {
  // Regex: Matches 'as =' assignment
  const asDefaultMatch = content.match(/as\s*=\s*([^,\n]+)/)
  if (asDefaultMatch) {
    let asDefault = asDefaultMatch[1]
      .trim()
      .split(' : ')[0]
      .replace(/['"]/g, '')
      .replace(/href \? a : /, '')
      .replace(/href \? 'a' : /, '')

    // Remove extra braces and clean up the string
    asDefault = asDefault.replace(/^{{/, '{').replace(/}}$/, '}')
    asDefault = asDefault.replace(/^{/, '').replace(/}$/, '')

    return asDefault.includes('?') ? `{${asDefault}}` : asDefault
  }
  return 'div'
}

// Function to extract component props (e.g., ComponentProps<typeof Button>)
const extractComponentProps = (content: string) => {
  // Regex: Matches 'ComponentProps<typeof ComponentName>' or 'extends ComponentProps<typeof ComponentName>'
  const componentPropsMatches =
    content.match(
      /(?:extends ComponentProps<typeof ([^>]+)>|ComponentProps<typeof ([^>]+)>)/g
    ) || []
  return componentPropsMatches.map((match) => {
    // Regex: Extracts component name from the match
    const componentName = match.match(/typeof ([^>]+)/)[1]
    return {
      name: componentName,
      props: `ComponentProps<typeof ${componentName}>`,
    }
  })
}

const parsedProps = extractProps(componentFileContent)
const parsedAstroProps = extractDefaultProps(componentFileContent)
const asDefault = extractAsDefault(componentFileContent)

// Function to get the default value for a prop
const getDefaultValue = (name: string, type: string) => {
  if (name in parsedAstroProps) {
    return parsedAstroProps[name]
  }

  return '-'
}

// Prepare the table body data
const tableBody = [
  ...parsedProps.map((item) => [
    item.name,
    item.type.replace(/\s*\|?\s*undefined/, '').trim(),
    getDefaultValue(item.name, item.type),
  ]),
  ['as', 'HTMLTag', asDefault],
  ['HTML Attributes', `Polymorphic<${asDefault}>`, '-'],
]
---

<Table
  size="md"
  class:list={['props-table']}
  header={['Prop', 'Type', 'Default']}
  body={tableBody}
/>

<style is:global lang="scss">
  .props-table {
    overflow: auto;
  }
</style>
