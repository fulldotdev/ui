---
import { getCollection, type CollectionEntry } from "astro:content"

import type { BlockSchema } from "@/lib/schemas"

type Props = BlockSchema

const props = Astro.props

function getHref(entry: CollectionEntry<"pages">) {
  // If there is no content, return undefined
  if (!entry.data.sections?.length && !entry.body?.length) return undefined
  // If the page is the index, return the root
  if (entry.id === "index") return "/"
  // else return href b yid
  return `/${entry.id}/`
}

// Populate references to pages of each type
async function populateReferences<
  T extends string | string[] | object[] | undefined,
>(value: T) {
  // If undefined, return undefined
  if (value === undefined) return
  // If an array of objects, return the objects
  else if (
    Array.isArray(value) &&
    value.every((item) => typeof item === "object")
  ) {
    return value
  }

  const pages =
    value === typeof "string"
      ? // If a string, return an array of pages matching the glob
        await getCollection("pages", (entry) => entry.id.startsWith(value))
      : // else if a single string, return an array of pages matching the id
        await getCollection("pages", (entry) => entry.id === value)

  // Return an array of page summaries with href and data
  return pages.map((entry) => ({
    href: getHref(entry),
    ...entry.data,
  }))
}

// Populate each page type
if ("items" in props) {
  props.items = (await populateReferences(props.items)) as any
}

const blockImports = import.meta.glob("./blocks/**/*.astro")
const { block, ...rest } = props
const blockPath = `./blocks/${block}.astro`
const blockImport = (await blockImports[blockPath]?.()) as any
const BlockComponent = blockImport?.default as any
---

{
  BlockComponent && (
    <BlockComponent {...rest}>
      <slot />
      {"html" in rest && <Fragment set:html={rest.html} />}
    </BlockComponent>
  )
}
