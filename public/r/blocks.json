{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "blocks",
  "type": "registry:component",
  "registryDependencies": [
    "@fulldev/article-1",
    "@fulldev/article-2",
    "@fulldev/articles-1",
    "@fulldev/articles-2",
    "@fulldev/articles-3",
    "@fulldev/articles-4",
    "@fulldev/banner-1",
    "@fulldev/banner-2",
    "@fulldev/contact-1",
    "@fulldev/contact-2",
    "@fulldev/contact-3",
    "@fulldev/content-1",
    "@fulldev/content-2",
    "@fulldev/content-3",
    "@fulldev/content-4",
    "@fulldev/cta-1",
    "@fulldev/cta-2",
    "@fulldev/cta-3",
    "@fulldev/cta-4",
    "@fulldev/cta-5",
    "@fulldev/cta-6",
    "@fulldev/cta-7",
    "@fulldev/cta-8",
    "@fulldev/faqs-1",
    "@fulldev/faqs-2",
    "@fulldev/faqs-3",
    "@fulldev/faqs-4",
    "@fulldev/features-1",
    "@fulldev/features-2",
    "@fulldev/features-3",
    "@fulldev/features-4",
    "@fulldev/features-5",
    "@fulldev/features-6",
    "@fulldev/footer-1",
    "@fulldev/footer-2",
    "@fulldev/header-1",
    "@fulldev/header-2",
    "@fulldev/header-3",
    "@fulldev/hero-1",
    "@fulldev/hero-2",
    "@fulldev/hero-3",
    "@fulldev/hero-4",
    "@fulldev/hero-5",
    "@fulldev/hero-6",
    "@fulldev/hero-7",
    "@fulldev/hero-8",
    "@fulldev/hero-9",
    "@fulldev/hero-10",
    "@fulldev/hero-11",
    "@fulldev/hero-12",
    "@fulldev/hero-13",
    "@fulldev/logos-1",
    "@fulldev/logos-2",
    "@fulldev/logos-3",
    "@fulldev/pricings-1",
    "@fulldev/pricings-2",
    "@fulldev/pricings-3",
    "@fulldev/product-1",
    "@fulldev/products-1",
    "@fulldev/products-2",
    "@fulldev/products-3",
    "@fulldev/products-4",
    "@fulldev/products-5",
    "@fulldev/reviews-1",
    "@fulldev/reviews-2",
    "@fulldev/reviews-3",
    "@fulldev/reviews-4",
    "@fulldev/reviews-5",
    "@fulldev/services-1",
    "@fulldev/services-2",
    "@fulldev/services-3",
    "@fulldev/services-4",
    "@fulldev/services-5",
    "@fulldev/services-6",
    "@fulldev/services-7",
    "@fulldev/content-5",
    "@fulldev/content-6"
  ],
  "files": [
    {
      "path": "src/components/block.astro",
      "content": "---\nimport { getCollection, getEntry, type CollectionEntry } from \"astro:content\"\n\nimport type { BlockSchema, PageSchema } from \"@/lib/schemas\"\n\ntype Props = BlockSchema & PageSchema\n\n// Helper functions\nfunction getHref(entry: CollectionEntry<\"pages\">) {\n  // If there is no content, return undefined\n  if (!entry.data.sections?.length && !entry.body?.length && !entry.data.block)\n    return undefined\n  // If the page is the index, return the root\n  if (entry.id === \"index\") return \"/\"\n  // else return href b yid\n  return `/${entry.id}/`\n}\n\nconst pages = await getCollection(\"pages\")\n\n// Get a single reference by file path\nasync function getRef(value: string) {\n  const entry = pages.find((page) => `/${page.filePath}` === value)\n  const layout = entry?.data?.layout\n    ? await getEntry(\"layouts\", entry?.data?.layout)\n    : undefined\n  if (!entry) return\n  return {\n    ...layout?.data,\n    href: getHref(entry),\n    ...entry.data,\n  }\n}\n\n// Get multiple references by file paths\nasync function getRefs(values: string[]) {\n  return (await Promise.all(values.map(getRef))).filter(\n    (item) => item !== undefined\n  )\n}\n\n// Get a glob of pages by folder path\nasync function getGlob(value: string) {\n  return pages\n    .filter((page) => page.filePath?.startsWith(`src/content/pages/${value}`))\n    .map((page) => ({\n      href: getHref(page),\n      ...page.data,\n    }))\n}\n\n// Recursively resolve references in items\nasync function resolveItem(item: any): Promise<any> {\n  if (!item) return item\n\n  const resolved = { ...item }\n\n  // Resolve single reference\n  if (resolved.ref) {\n    const referencedItem = await getRef(resolved.ref)\n    resolved.item = referencedItem\n    delete resolved.ref\n  }\n\n  // Resolve multiple references\n  if (resolved.refs) {\n    resolved.items = await getRefs(resolved.refs)\n    delete resolved.refs\n  }\n\n  // Resolve glob pattern\n  if (resolved.glob) {\n    resolved.items = await getGlob(resolved.glob)\n    delete resolved.glob\n  }\n\n  // Recursively resolve nested items\n  if (resolved.items) {\n    resolved.items = await Promise.all(\n      resolved.items.map((nestedItem: any) => resolveItem(nestedItem))\n    )\n  }\n\n  // Recursively resolve single nested item\n  if (resolved.item) {\n    resolved.item = await resolveItem(resolved.item)\n  }\n\n  return resolved\n}\n\nconst { block, ref, refs, glob, ...props } = Astro.props\n\n// Populate references at top level\nif (ref) {\n  props.item = await getRef(ref)\n}\nif (refs) {\n  props.items = await getRefs(refs)\n}\nif (glob) {\n  props.items = await getGlob(glob)\n}\n\n// Recursively resolve nested items\nif (props.items) {\n  props.items = await Promise.all(\n    props.items.map((item: any) => resolveItem(item))\n  )\n}\n\nconst blockImports = import.meta.glob(\"./blocks/**/*.astro\")\nconst blockPath = `./blocks/${block}.astro`\nconst blockImport = (await blockImports[blockPath]?.()) as any\nconst BlockComponent = blockImport?.default as any\n---\n\n{\n  BlockComponent && (\n    <BlockComponent {...props}>\n      <slot />\n      {\"html\" in props && <Fragment set:html={props.html} />}\n    </BlockComponent>\n  )\n}\n",
      "type": "registry:component"
    }
  ]
}
